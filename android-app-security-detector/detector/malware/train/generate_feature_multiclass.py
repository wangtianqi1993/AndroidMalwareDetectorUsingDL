# !/usr/bin/env python
# -*- coding: utf-8 -*-
__author__ = 'wtq'

import csv
import time
import os
import os.path
import re
import sys
import jieba
import json
from sklearn.linear_model import LogisticRegression
import numpy
from numpy import zeros
from pymongo import MongoClient
from itertools import islice
from detector.config import MONGODB_HOST, MONGODB_PORT
from detector.logger import DetectorLogger
# from detector.malware.train.tf_model.auto_encoder import AutoEncoder

logger = DetectorLogger()
client = MongoClient(MONGODB_HOST, MONGODB_PORT)
db = client.detector


class ExtractFeature(object):
    def split_words(self, file_path, word_dict):
        """

        :param file_path: the file which you want to split words
        :param word_dict: the result of split, value is the sum of
               key appear's time during the file
        :return:
        """
        file_object = open(file_path)
        try:
            file_content = file_object.read()
        finally:
            file_object.close()
        words = jieba.cut(file_content)
        for word in words:
            if len(word) > 2:
                if not bool(re.search('\.|[0-9]|[(){}+-/";:=]|\*|\\n', word)):
                    if word not in word_dict:
                        word_dict[word] = 1
                    else:
                        word_dict[word] += 1

    def scan_file(self, file_path, word_dict):
        """
        scan file under file_path save it into code_dict
        :param file_path:
        :param word_dict:
        :return:
        """
        files = os.listdir(file_path)
        for fi in files:
            fi_d = os.path.join(file_path, fi)
            if os.path.isdir(fi_d):
                self.scan_file(fi_d, word_dict)
            else:
                if os.path.splitext(fi_d)[1] == '.java':
                    self.split_words(fi_d, word_dict)
        return word_dict

    def create_feature(self, word_dict, stand_feature):
        """
        create_feature your word_dict's word if in malware_feature
        :param path:
        :param word_dict:
        :return:
        """
        feature_vector = zeros(len(stand_feature))
        for key in word_dict:
            if key in stand_feature:
                # use 0 1 to sign if the feature appear
                feature_vector[stand_feature.index(key)] = 1
                # feature_vector[stand_feature.index(key)] = word_dict[key]
        return feature_vector

    def generate_vector(self):
        """
        generate the trian data set like [1,0,0,1,1,1,0] the final element sign benign or malware apk
        benign 0 malware 1
        :return:
        """
        # get the standard feature
        with open(
                "/home/wtq/develop/workspace/gitlab/android-app-security-detector/detector/malware/malware_feature.json",
                'r') as f:

            js = json.loads(f.read())
        feature = []
        feature_label = []
        feature_vector = []
        test_vector = []
        test_label = []
        test_feature = []
        # all_vector use to save all sample for visualization
        all_vector = []

        benign_sum = 0
        malware_sum = 0
        for item in db.benign_source.find():
            temp = self.create_feature(item["train-word"], js)
            # give the final sign
            all_vector.append(temp)
            benign_sum += 1
            if benign_sum < 900:
                feature_label.append(0)
                feature_vector.append(temp)
            else:
                test_vector.append(temp)
                test_label.append(0)

        for item in db.malware_source.find():
            temp = self.create_feature(item["train-word"], js)
            all_vector.append(temp)
            malware_sum += 1
            if malware_sum < 800:
                feature_label.append(1)
                feature_vector.append(temp)
            else:
                test_vector.append(temp)
                test_label.append(1)

        # feature[0] save the feature, feature[1] save the feature's label
        feature.append(feature_vector)
        feature.append(feature_label)
        test_feature.append(test_vector)
        test_feature.append(test_label)

        return feature, test_feature, all_vector

    def write_feature_to_file(self, file_path):
        """
        write a apk feature([[0,1,1,1,0,0,0,0,1],[0]]) to a file
        one sample to one line in the file
        :return:
        """
        train_feature, test_feature, all = self.generate_vector()
        apk = []
        with open(file_path, "wb") as f:
            writer = csv.writer(f)

            for index in range(0, len(train_feature[0])):
                apk_sample = list(train_feature[0][index])
                apk_sample = map(float, apk_sample)
                if int(train_feature[1][index]) == 1:
                    apk_sample.extend([0.0, 1.0])
                else:
                    apk_sample.extend([1.0, 0.0])

                apk.append(apk_sample)

            for index in range(0, len(test_feature[0])):
                apk_sample = list(test_feature[0][index])
                apk_sample = map(float, apk_sample)
                if int(test_feature[1][index]) == 1:
                    apk_sample.extend([0.0, 1.0])
                else:
                    apk_sample.extend([1.0, 0.0])

                apk.append(apk_sample)

            writer.writerows(apk)


if __name__ == "__main__":
    feature = ExtractFeature()
    # feature.write_feature_to_file("/home/wtq/apk_classification2.csv")
    feature.write_feature_to_file('/home/wtq/malware_feature_with_times.csv')

