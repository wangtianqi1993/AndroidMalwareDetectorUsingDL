# !/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'wtq'

import os
import collections
import json
import time
from numpy import *
from androguard.core import androconf
from androguard.core.bytecodes import apk
from sklearn.linear_model import LogisticRegression
from sklearn.externals import joblib
from sklearn import metrics


class TrainMalware():
    def __init__(self):
        self.base_permission = ["ACCESS_CHECKIN_PROPERTIES", "ACCESS_COARSE_LOCATION", "ACCESS_FINE_LOCATION", "ACCESS_LOCATION_EXTRA_COMMANDS", "ACCESS_NETWORK_STATE", "ACCESS_NOTIFICATION_POLICY", "ACCESS_WIFI_STATE", "ACCOUNT_MANAGER", "ADD_VOICEMAIL", "BATTERY_STATS", "BIND_ACCESSIBILITY_SERVICE", "BIND_APPWIDGET", "BIND_CARRIER_MESSAGING_SERVICE", "BIND_CARRIER_SERVICES", "BIND_CHOOSER_TARGET_SERVICE", "BIND_DEVICE_ADMIN", "BIND_DREAM_SERVICE", "BIND_INCALL_SERVICE", "BIND_INPUT_METHOD", "BIND_MIDI_DEVICE_SERVICE", "BIND_NFC_SERVICE", "BIND_NOTIFICATION_LISTENER_SERVICE", "BIND_PRINT_SERVICE", "BIND_REMOTEVIEWS", "BIND_TELECOM_CONNECTION_SERVICE", "BIND_TEXT_SERVICE", "BIND_TV_INPUT", "BIND_VOICE_INTERACTION", "BIND_VPN_SERVICE", "BIND_WALLPAPER", "BLUETOOTH", "BLUETOOTH_ADMIN", "BLUETOOTH_PRIVILEGED", "BODY_SENSORS", "BROADCAST_PACKAGE_REMOVED", "BROADCAST_SMS", "BROADCAST_STICKY", "BROADCAST_WAP_PUSH", "CALL_PHONE", "CALL_PRIVILEGED", "CAMERA", "CAPTURE_AUDIO_OUTPUT", "CAPTURE_SECURE_VIDEO_OUTPUT", "CAPTURE_VIDEO_OUTPUT", "CHANGE_COMPONENT_ENABLED_STATE", "CHANGE_CONFIGURATION", "CHANGE_NETWORK_STATE", "CHANGE_WIFI_MULTICAST_STATE", "CHANGE_WIFI_STATE", "CLEAR_APP_CACHE", "CONTROL_LOCATION_UPDATES", "DELETE_CACHE_FILES", "DELETE_PACKAGES", "DIAGNOSTIC", "DISABLE_KEYGUARD", "DUMP", "EXPAND_STATUS_BAR", "FACTORY_TEST", "FLASHLIGHT", "GET_ACCOUNTS", "GET_ACCOUNTS_PRIVILEGED", "GET_PACKAGE_SIZE", "GET_TASKS", "GLOBAL_SEARCH", "INSTALL_LOCATION_PROVIDER", "INSTALL_PACKAGES", "INSTALL_SHORTCUT", "INTERNET", "KILL_BACKGROUND_PROCESSES", "LOCATION_HARDWARE", "MANAGE_DOCUMENTS", "MASTER_CLEAR", "MEDIA_CONTENT_CONTROL", "MODIFY_AUDIO_SETTINGS", "MODIFY_PHONE_STATE", "MOUNT_FORMAT_FILESYSTEMS", "MOUNT_UNMOUNT_FILESYSTEMS", "NFC", "PACKAGE_USAGE_STATS", "PERSISTENT_ACTIVITY", "PROCESS_OUTGOING_CALLS", "READ_CALENDAR", "READ_CALL_LOG", "READ_CONTACTS", "READ_EXTERNAL_STORAGE", "READ_FRAME_BUFFER", "READ_INPUT_STATE", "READ_LOGS", "READ_PHONE_STATE", "READ_SMS", "READ_SYNC_SETTINGS", "READ_SYNC_STATS", "READ_VOICEMAIL", "REBOOT", "RECEIVE_BOOT_COMPLETED", "RECEIVE_MMS", "RECEIVE_SMS", "RECEIVE_WAP_PUSH", "RECORD_AUDIO", "REORDER_TASKS", "REQUEST_IGNORE_BATTERY_OPTIMIZATIONS", "REQUEST_INSTALL_PACKAGES", "RESTART_PACKAGES", "SEND_RESPOND_VIA_MESSAGE", "SEND_SMS", "SET_ALARM", "SET_ALWAYS_FINISH", "SET_ANIMATION_SCALE", "SET_DEBUG_APP", "SET_PREFERRED_APPLICATIONS", "SET_PROCESS_LIMIT", "SET_TIME", "SET_TIME_ZONE", "SET_WALLPAPER", "SET_WALLPAPER_HINTS", "SIGNAL_PERSISTENT_PROCESSES", "STATUS_BAR", "SYSTEM_ALERT_WINDOW", "TRANSMIT_IR", "UNINSTALL_SHORTCUT", "UPDATE_DEVICE_STATS", "USE_FINGERPRINT", "USE_SIP", "VIBRATE", "WAKE_LOCK", "WRITE_APN_SETTINGS", "WRITE_CALENDAR", "WRITE_CALL_LOG", "WRITE_CONTACTS", "WRITE_EXTERNAL_STORAGE", "WRITE_GSERVICES", "WRITE_SECURE_SETTINGS", "WRITE_SETTINGS", "WRITE_SYNC_SETTINGS", "WRITE_VOICEMAIL"]

    def get_permission(self, apk_path, label):
        permission = []
        labels = []
        merge_permission = {}
        for temp in os.listdir(apk_path):
            path = os.path.join(apk_path, temp)
            ret_type = androconf.is_android(path)
            if ret_type == "APK":
                a = apk.APK(path)
                if a.is_valid_APK():
                    permissions = a.get_requested_permissions()
                    temp_l = []
                    for i in permissions:
                        temp_l.append(i.split(".")[-1])
                    permission.append(self.conver_vector(temp_l))
                    labels.append(label)
            merge_permission[temp] = temp_l
        # return merge_permission
        return [permission, labels]

    def conver_vector(self, permission):
        vector = [0]*len(self.base_permission)
        for i in permission:
            if i in self.base_permission:
                vector[self.base_permission.index(i)] = 1
        return vector

    def get_feature(self, malware_path, benign_path):
        malware_feature = self.get_permission(malware_path, 1)
        benign_feature = self.get_permission(benign_path, 0)
        feature = []
        label = []

        for i in malware_feature[0]:
            feature.append(i)
        label.extend(malware_feature[1])

        for i in benign_feature[0]:
            feature.append(i)
        label.extend(benign_feature[1])
        return feature, label

    def train_model(self, malware_path, benign_path):
        """
        malware label 1,  benign label 0
        :param malware_path:
        :param benign_path:
        :return:
        """
        lr = LogisticRegression(class_weight={1: 2})
        feature, label = self.get_feature(malware_path, benign_path)
        lr.fit(feature, label)
        joblib.dump(lr, "model_store/lr_model.pkl")
        # return lr

    def test_model(self, apk_path):
        """
        目前有86.67%的准确率
        :param apk_path:
        :return:
        """

        benign_apk_path = apk_path + "/benign"
        malware_apk_path = apk_path + "/malware"
        feature_benign = self.get_permission(benign_apk_path, 0)
        feature_malware = self.get_permission(malware_apk_path, 1)

        feature = []
        feature.extend(feature_benign[0])
        feature.extend(feature_malware[0])
        label = []
        label.extend(feature_benign[1])
        label.extend(feature_malware[1])
        # lr = self.train_model("/home/wtq/develop/workspace/mumaTrainApk/mumaApk", "/home/wtq/develop/workspace/mumaTrainApk/formalApk")
        lr = joblib.load("model_store/lr_model.pkl")

        predict = lr.predict(feature)
        output_score = []
        for item in lr.predict_proba(feature):
            output_score.append(item[1])

        confusion = metrics.confusion_matrix(label, predict)
        print confusion
        # 计算模型的正确率
        print "accuracy->", metrics.accuracy_score(label, predict)
        # 计算模型的精确率
        print "precision->", metrics.precision_score(label, predict)
        # 计算模型的召回率
        print "recall->", metrics.recall_score(label, predict)
        # 计算模型的f1值
        print "f1->", metrics.f1_score(label, predict)
        # 计算模型的AUC值
        print "AUC->", metrics.roc_auc_score(label, output_score)

        # for item in feature[0]:
        #     print lr.predict(item)

    def get_diffent_per(self):
        temp_permission = [('READ_PHONE_STATE', 23), ('WRITE_EXTERNAL_STORAGE', 22), ('INTERNET', 20), ('ACCESS_NETWORK_STATE', 19), ('MOUNT_UNMOUNT_FILESYSTEMS', 19), ('ACCESS_FINE_LOCATION', 18), ('ACCESS_WIFI_STATE', 18), ('RECEIVE_BOOT_COMPLETED', 17), ('ACCESS_COARSE_LOCATION', 16), ('CHANGE_WIFI_STATE', 16), ('READ_SMS', 16), ('RECEIVE_SMS', 16), ('READ_CONTACTS', 16), ('RECORD_AUDIO', 14), ('READ_LOGS', 14), ('WRITE_SMS', 13), ('WRITE_CONTACTS', 13), ('CHANGE_NETWORK_STATE', 13), ('SEND_SMS', 12), ('PROCESS_OUTGOING_CALLS', 12), ('BAIDU_LOCATION_SERVICE', 11), ('WRITE_SETTINGS', 10), ('CALL_PHONE', 9), ('WAKE_LOCK', 8), ('VIBRATE', 7), ('READ_CALL_LOG', 7), ('BROADCAST_STICKY', 6), ('MODIFY_PHONE_STATE', 6)]
        obj_p = []
        for item in temp_permission:
            obj_p.append(item[0])
        all_permission = self.get_permission("/home/wtq/develop/workspace/mumaTrainApk/mumaApk", 1)
        obj_permission = {}
        for apk in all_permission:
            obj_permission[apk] = []
            for item in all_permission[apk]:
                print item
                if item in obj_p:
                    obj_permission[apk].append(item)
        with open("apk_frequence_permission.json", "w") as f:
            json.dump(obj_permission, f)

    def sigmoid(self, inx):
            return 1.0/(1+exp(-inx))

    def train_logistic_regression(self, data_mat_in, class_labels, opts):
        """
        this is the gradient ascent algorithm for logistic regression
        :param data_mat_in:
        :param class_labels:
        :return:
        """

        start_time = time.time()
        data_matrix = mat(data_mat_in)
        label_mat = mat(class_labels).transpose()
        num_samples, num_features = shape(data_matrix)
        print 'num_samples', num_samples
        print 'num_features', num_features
        alpha = opts['alpha']
        max_cycles = opts['max_cycles']
        weights = ones((num_features, 1))
        # print "data_matrix", data_matrix
        # print "data_label", label_mat
        # print "mul", data_matrix*weights

        for k in range(max_cycles):
            # 最原始的梯度下降法将整个训练集合中的所有样本与weights相乘，叠加求和再计算误差
            # 体现在data_matrix*weights中，每迭代一次就要遍历整个样本集合，集合大时比较耗时，与之对应的是随机梯度下降（上升）
            # 改进的方法是一次仅用一个样本点（的回归误差）来更新回归系数。这个方法叫随机梯度下降算法。由于可以在新的样本到来的时候对
            # 分类器进行增量的更新（假设我们已经在数据库A上训练好一个分类器h了，那新来一个样本x。对非增量学习算法来说，我们需要把x和数据库A
            # 混在一起，组成新的数据库B，再重新训练新的分类器。但对增量学习算法，我们只需要用新样本x来更新已有分类器h的参数即可），所以它属于
            # 在线学习算法。与在线学习相对应，一次处理整个数据集的叫“批处理”
            if opts['optimize_type'] == 'graddescent':
                output = self.sigmoid(data_matrix*weights)
                error = (label_mat - output)
                # print "data_matrix...", data_matrix.transpose()
                print "error...", error
                # print "mul...", data_matrix.transpose()*error
                weights = weights + alpha * data_matrix.transpose()*error

            elif opts['optimize_type'] == 'stoc_graddescent':
                # 一次仅用一个样本点（的回归误差）来更新回归系数
                for i in range(num_samples):
                    output = self.sigmoid(data_matrix[i, :]*weights)
                    error = label_mat[i, 0] - output
                    # print "data_matrix", data_matrix[i, :].transpose()
                    print "error..", error
                    # print "mul..", data_matrix[i, :].transpose()*error
                    weights = weights + alpha*data_matrix[i, :].transpose()*error

            elif opts['optimize_type'] == 'smooth_stoc_graddescent':
                # 基于步长逐渐减小的优化梯度下降,且随机的选择样本
                data_index = range(num_samples)
                for i in range(num_samples):
                    alpha = 4.0 / (1.0 + k + i) + 0.01
                    rand_index = int(random.uniform(0, len(data_index)))
                    output = self.sigmoid(data_matrix[data_index[rand_index], :]*weights)
                    error = label_mat[data_index[rand_index], 0] - output
                    weights = weights + alpha * data_matrix[data_index[rand_index], :].transpose()*error
                    # during one interation, delete the optimized sample
                    del(data_index[rand_index])

            else:
                raise NameError('Not support optimize method type!')
        print "weights", weights
        print 'Congratulations, training complete! Took %fs!' % (time.time() - start_time)
        return weights

    def test_logistic_regression(self, weights, test_x, test_y):
        num_samples, num_features = shape(test_x)
        match_count = 0
        test_x = mat(test_x)
        test_y = mat(test_y).transpose()
        for i in xrange(num_samples):
            predict = self.sigmoid(test_x[i, :] * weights)[0, 0] > 0.5
            if predict == bool(test_y[i, 0]):
                match_count += 1
        accuracy = float(match_count) / num_samples
        print accuracy

    def use_logist_regresstion(self, malware_path, benign_path):
        test_parameter = {}
        test_parameter['alpha'] = 0.001
        test_parameter['max_cycles'] = 100
        test_parameter['optimize_type'] = 'stoc_graddescent'
        feature, label = self.get_feature(malware_path, benign_path)
        train_feature = feature[:65]
        test_feature = feature[65:]
        train_label = label[:65]
        test_label = label[65:]
        weights = self.train_logistic_regression(train_feature, train_label, test_parameter)
        self.test_logistic_regression(weights, test_feature, test_label)


if __name__ == "__main__":
    tm = TrainMalware()
    print len(tm.base_permission)
    #tm.train_model("/home/wtq/develop/workspace/mumaTrainApk/mumaApk", "/home/wtq/develop/workspace/mumaTrainApk/formalApk")
    #tm.test_model("/home/wtq/develop/workspace/mumaTrainApk/testApk")
    # tm.use_logist_regresstion("/home/wtq/develop/workspace/mumaTrainApk/mumaApk", "/home/wtq/develop/workspace/mumaTrainApk/formalApk")
