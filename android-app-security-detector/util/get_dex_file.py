# !/usr/bin/env python
# -*- coding: utf-8 -*-
__author__ = 'wtq'

import os
import sys
import subprocess
import zipfile
from detector.logger import DetectorLogger

logger = DetectorLogger()


def get_dex_file(apk_path, dex_path, class_name=None):
    """
    extract the classes.dex file from apk
    对于恶意应用通过在每个恶意应用家族的名字加到生成的dex文件名字中，
    对于普通apk所有apk包含在同一级目录中，不会将上一子级目录的名字添加到dex文件中
    :return:
    """
    apklist = os.listdir(apk_path)
    print ('waiting...')
    if not os.path.exists(dex_path):
        os.makedirs(dex_path)

    for APK in apklist:
        # scan the sub dir under the input dir
        sub_path = os.path.join(apk_path, APK)
        if os.path.isdir(sub_path):
            get_dex_file(sub_path, dex_path, APK)
            # 上一个get_dex_file执行完成返回到该函数时，由return直接返回。否则子目录当成apk继续向下执行会报错
            return
        try:
            print 'apk', os.path.join(apk_path, APK)
            portion = os.path.splitext(APK)
            newname = portion[0] + '.zip'
            if portion[1] == '.apk':
                # 使用rename得在当前目录下所以加上os.path,join(),也可使用partion[1]='.zip'
                os.rename(os.path.join(apk_path, APK), os.path.join(apk_path, newname))

            apkname = portion[0]
            zip_apk_path = os.path.join(apk_path, newname)
            z = zipfile.ZipFile(zip_apk_path, 'r')

            for filename in z.namelist():

                if filename.endswith('.dex'):
                    dexfilename = class_name + "." + apkname + '.dex'
                    dexfilepath = os.path.join(dex_path, dexfilename)
                    f = file(dexfilepath, 'a+')
                    f.write(z.read(filename))
                    f.close()

        except Exception, e:
            logger.info('error')
            logger.info(e)
    return


def dex_to_java(apk_path, source_path):
    """
    convert .apk to .java
    :return:
    """
    ps1 = subprocess.Popen(
        "bash /home/wtq/develop/workspace/gitlab/android-app-security-detector/detector/trace_malware/trace_util/dex_to_class.sh %s %s" % (
        str(apk_path), str(source_path)), shell=True)
    # 等待dex_to_class线程执行完成再顺序执行
    ps1.wait()

    ps2 = subprocess.Popen("bash /home/wtq/develop/workspace/gitlab/android-app-security-detector/detector/trace_malware/trace_util/class_to_java.sh %s" %
                     (str(source_path)), shell=True)

    # 通过ps2.wait使class_to_java充分的反编译
    ps2.wait()
    print "end!"

if __name__ == "__main__":
    get_dex_file("/media/wtq/0008943A0007A7BC/apk-resource/android-malware/malware_engineering", "/media/wtq/0008943A0007A7BC/apk-resource/android-malware/malware_with_class/")
    # dex_to_java("/media/wtq/0008943A0007A7BC/apk-resource/benign-apk/1900/apk6", "/media/wtq/0001CADE0007CDD4/ApkResourse/apk-resource/benign_source_new")
